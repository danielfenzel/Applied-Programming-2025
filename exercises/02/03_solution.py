# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "marimo",
#     "numpy==2.2.4",
#     "scipy==1.15.2",
#     "matplotlib==3.10.1",
#     "pandas==2.2.3",
# ]
# ///

# Copyright 2025 n-squared LAB @ FAU Erlangen-Nürnberg

import marimo

__generated_with = "0.12.4"
app = marimo.App(width="medium")


@app.cell
def _():
    import marimo as mo
    return (mo,)


@app.cell
def _(mo):
    # Title
    mo.md("# EMG Signal Processing Exercise")
    return


@app.cell
def _(mo):
    # Introduction
    mo.md("""
    ## Introduction to EMG Signal Processing

    In this exercise, you will process EMG (Electromyography) signals. EMG measures the electrical activity of muscles, which is crucial for understanding muscle function and movement.

    ### Key Concepts

    #### 1. EMG Signals
    - EMG signals are electrical potentials generated by muscle fibers during contraction
    - Surface EMG (sEMG) is recorded using electrodes placed on the skin
    - The raw signal contains both the muscle activity and various types of noise

    #### 2. Data Storage (Pickle Files)
    - A pickle file (`.pkl`) is a Python-specific file format for serializing and deserializing Python objects
    - It's used to store complex data structures (like our EMG data) in a way that preserves their structure
    - Our data contains:
        - `biosignal`: The raw EMG data in a 3D array (channels × windowsize × window)
        - `ground_truth_sampling_frequency`: The rate at which the signal was recorded

    #### 3. Signal Processing Steps

    **a) Bandpass Filtering**
    - Why filter? Raw EMG signals contain noise from:
        - Power line interference (50/60 Hz)
        - Movement artifacts
        - Other biological signals
    - The Nyquist Theorem states that to accurately represent a signal, we must sample at least twice the highest frequency of interest
    - For EMG, we typically use:
        - Low cutoff: 20 Hz (removes movement artifacts and low-frequency noise)
        - High cutoff: 450 Hz (removes high-frequency noise and aliasing)

    **b) RMS (Root Mean Square)**
    - RMS is a measure of signal amplitude
    - Why use RMS?
        - EMG signals are alternating (positive and negative)
        - RMS provides a positive value representing the signal's power
        - Helps visualize muscle activation patterns
    - We use a 100ms window to calculate RMS, which:
        - Smooths the signal
        - Provides a good balance between temporal resolution and noise reduction

    #### 4. Visualization
    We'll create plots showing:

    1. Original EMG signal (raw data)
    2. Filtered signal (after bandpass filtering)
    3. RMS signal (amplitude envelope)

    This will help us understand how each processing step affects the signal and why each step is necessary.
    """)
    return


@app.cell
def _(mo):
    # Step 1: Loading the data
    mo.md("""
    ## Step 1: Loading and Understanding the Data

    First, let's load the data file and examine its structure. The data contains:
    - `biosignal`: The EMG data in a 3D array format (channels × windowsize × window)
    - `['device_information']['sampling_frequency']`: The sampling rate of the signal

    We'll need to:

    1. Load the data and examine its structure
    2. Extract the EMG signal and sampling rate
    3. Restructure the EMG data to have each channel in a separate array

    Write your code below:
    """)
    return


@app.cell
def _():
    # Code cell for loading data
    import numpy as np  # For numerical operations and array handling
    import pandas as pd  # For data loading and manipulation

    # Load the data from a pickle file
    # A pickle file is a Python-specific file format that can store complex data structures
    data = pd.read_pickle('/home/oj98yqyk/code/teaching/applied-programming/exercises/02/data.pkl')

    # Display basic information about the data structure
    print("Data structure:")
    print("-" * 50)
    print(f"Data type: {type(data)}")  # Shows what type of object we're working with
    print(f"Data shape: {data.shape if hasattr(data, 'shape') else 'N/A'}")  # Shows dimensions if it's an array
    print("\nAvailable keys in data:")
    print("-" * 50)
    # Print all available keys in the data dictionary
    for key in data.keys():
        print(f"- {key}")
    print("-" * 50)

    # Extract the EMG signal and sampling rate from the data dictionary
    # 'biosignal' contains the raw EMG data in a 3D array format
    emg_signal = data['biosignal']
    # 'sampling_frequency' tells us how many samples were recorded per second
    sampling_rate = data['device_information']['sampling_frequency']

    # Display information about the EMG signal
    print("\nEMG Signal information:")
    print("-" * 50)
    print(f"Signal shape: {emg_signal.shape}")  # Shows the dimensions of the EMG data
    print(f"Number of channels: {emg_signal.shape[0]}")  # How many EMG channels we have
    print(f"Window size: {emg_signal.shape[1]}")  # Number of samples in each window
    print(f"Number of windows: {emg_signal.shape[2]}")  # How many time windows we have
    print(f"Sampling rate: {sampling_rate} Hz")  # How many samples per second
    return data, emg_signal, key, np, pd, sampling_rate


@app.cell
def _(mo):
    # Step 2: Restructuring the EMG Data
    mo.md("""
    ## Step 2: Restructuring the EMG Data

    Now that we understand the data structure, we need to restructure the EMG signal.
    Currently, it's in the format: channels × windowsize × window

    We need to:

    1. Reshape the data to combine all windows for each channel
    2. Create a 2D array where each row represents a channel's continuous signal

    Write your code below:
    """)
    return


@app.cell
def _(emg_signal):
    # Code cell for restructuring EMG data
    # Get the number of channels from the first dimension of the EMG signal
    num_channels = emg_signal.shape[0]

    # Restructure the 3D array to a 2D array
    # The original data is in format: channels × windowsize × window
    # We want to convert it to: channels × (windowsize × window)
    # This combines all windows for each channel into one continuous signal

    # First, transpose to get windows × samples × channels
    # Then reshape to combine all windows for each channel
    channel_data = emg_signal.transpose(2, 1, 0).reshape(-1, num_channels).T

    # Display information about the restructured data
    print("\nRestructured EMG Data:")
    print("-" * 50)
    print(f"Original shape: {emg_signal.shape}")  # Original 3D shape
    print(f"New shape: {channel_data.shape}")  # New 2D shape
    print(f"Number of channels: {emg_signal.shape[0]}")  # Number of EMG channels
    print(f"Total samples per channel: {num_channels}")  # Total number of samples per channel
    return channel_data, num_channels


@app.cell
def _(mo):
    # Step 3: Bandpass Filtering
    mo.md("""
    ## Step 3: Bandpass Filtering

    Now, apply a bandpass filter to the EMG signal. For surface EMG, typical cutoff frequencies are:
    - Low cutoff: 20 Hz
    - High cutoff: 450 Hz

    You'll need to:
    1. Import scipy.signal
    2. Design a bandpass filter
    3. Apply it to the EMG signal

    Write your code below:
    """)
    return


@app.cell
def _(channel_data, np, num_channels):
    # Code cell for bandpass filtering
    from scipy import signal  # Import signal processing functions

    # Define filter parameters
    # These frequencies define the range of signals we want to keep
    low_cut = 10  # Hz - removes low frequency noise and movement artifacts
    high_cut = 500  # Hz - removes high frequency noise and aliasing

    # Calculate normalized frequencies for the filter
    # Digital filters require frequencies to be normalized between 0 and 1
    # where 1 represents the Nyquist frequency (half the sampling rate)

    # Display filter parameters
    print("\nFilter Design Parameters:")
    print("-" * 50)


    # Design a 4th order Butterworth bandpass filter
    # This type of filter has a flat frequency response in the passband
    b, a = signal.butter(8, [low_cut, high_cut], btype='bandpass', fs=2000)

    # Pre-allocate array for filtered data
    # This is more efficient than growing a list
    num_samples = channel_data.shape[1]
    filtered_channels = np.zeros((num_channels, num_samples))

    # Apply the filter to each channel
    # filtfilt is used because it has zero phase delay
    for i in range(num_channels):
        filtered_channels[i, :] = signal.filtfilt(b, a, channel_data[i, :])

    # Display information about the filtered signal
    print("\nFiltered Signal Information:")
    print("-" * 50)
    print(f"Number of filtered channels: {num_channels}")
    print(f"Shape of filtered_channels: {filtered_channels.shape}")
    print(f"Type of filtered_channels: {type(filtered_channels)}")
    print(f"Filter cutoff frequencies: {low_cut} Hz to {high_cut} Hz")
    return a, b, filtered_channels, high_cut, i, low_cut, num_samples, signal


@app.cell
def _(mo):
    # Step 4: RMS Calculation
    mo.md("""
    ## Step 4: RMS Calculation

    Calculate the Root Mean Square (RMS) of the filtered signal. The RMS gives us the amplitude of the EMG signal.
    Use a window size of 100ms (convert this to samples using the sampling rate).

    Write your code below:
    """)
    return


@app.cell
def _(ch, channel_data, filtered_channels, np, rms_signals, sampling_rate):
    # Code cell for visualization
    import matplotlib.pyplot as plt  # For creating plots

    # Convert from 1-based to 0-based indexing for array access
    selected_channel = ch.value - 1

    # Create time array in seconds
    # Divide by sampling_rate to convert samples to seconds
    t = np.arange(len(channel_data[selected_channel])) / sampling_rate

    # Create figure with 3 subplots
    # sharex=True means all plots share the same x-axis
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 8), sharex=True)

    # Plot 1: Original EMG signal
    ax1.plot(t, channel_data[selected_channel])
    ax1.set_title(f'Original EMG Signal - Channel {ch.value}')
    ax1.set_ylabel('Amplitude (V)')

    # Plot 2: Filtered signal
    ax2.plot(t, filtered_channels[selected_channel])
    ax2.set_title(f'Bandpass Filtered Signal - Channel {ch.value}')
    ax2.set_ylabel('Amplitude (V)')

    # Plot 3: RMS signal
    ax3.plot(t, rms_signals[selected_channel])
    ax3.set_title(f'RMS Signal - Channel {ch.value}')
    ax3.set_ylabel('Amplitude (V)')
    ax3.set_xlabel('Time (s)')

    # Adjust layout to prevent label overlap
    plt.tight_layout()
    plt.show()
    return ax1, ax2, ax3, fig, plt, selected_channel, t


@app.cell
def _(filtered_channels, np, num_channels, sampling_rate):
    # Code cell for RMS calculation
    # Calculate window size in samples for 100ms
    window_size = int(0.1 * sampling_rate)  # 100ms window

    # Pre-allocate array for RMS signals
    # Same shape as filtered_channels
    rms_signals = np.zeros_like(filtered_channels)

    # Calculate RMS for each channel
    # RMS is calculated using a moving window
    # This smooths the signal and gives us the amplitude envelope
    for channel in range(num_channels):
        # Calculate RMS using convolution
        # Square the signal, apply a moving average, then take square root
        rms_signals[channel, :] = np.sqrt(np.convolve(filtered_channels[channel, :]**2, 
                                                    np.ones(window_size)/window_size,mode='same'))

    # Display information about the RMS signals
    print("\nRMS Signal Information:")
    print("-" * 50)
    print(f"Number of channels: {num_channels}")
    print(f"Shape of RMS signals: {rms_signals.shape}")
    print(f"Window size: {window_size} samples ({window_size/sampling_rate*1000:.1f} ms)")
    return channel, rms_signals, window_size


@app.cell
def _(mo, num_channels):
    # Channel selector
    # Create a slider to select which channel to visualize
    # Range is from 1 to number of channels
    ch = mo.ui.slider(1, num_channels, value=1, label="Select Channel")
    mo.md(f"""
    ## Select Channel to Visualize

    Use the slider below to select which channel you want to visualize:
    {ch}
    """)
    return (ch,)


@app.cell
def _(ch, channel_data, filtered_channels, plt, sampling_rate, signal):
    # Code cell for power spectrum visualization


    # Get the selected channel (convert from 1-based to 0-based indexing)
    selected_channel_2 = ch.value - 1

    # Calculate the power spectrum for both original and filtered signals
    # Use Welch's method to estimate the power spectral density
    f_orig, Pxx_orig = signal.welch(channel_data[selected_channel_2, :], 
                                  fs=sampling_rate, 
                                  nperseg=1024)
    f_filt, Pxx_filt = signal.welch(filtered_channels[selected_channel_2, :], 
                                  fs=sampling_rate, 
                                  nperseg=1024)

    # Create figure with two subplots
    fig2, (ax5, ax4) = plt.subplots(2, 1, figsize=(12, 8), sharex=True)

    # Plot original power spectrum
    ax5.semilogy(f_orig, Pxx_orig)
    ax5.set_title(f'Power Spectrum - Original Signal (Channel {ch.value})')
    ax5.set_ylabel('Power/Frequency (dB/Hz)')
    ax5.grid(True)

    # Add vertical lines to show filter cutoff frequencies
    ax5.axvline(x=5, color='r', linestyle='--', label='Low cutoff (5 Hz)')
    ax5.axvline(x=500, color='r', linestyle='--', label='High cutoff (500 Hz)')
    ax5.legend()

    # Plot filtered power spectrum
    ax4.semilogy(f_filt, Pxx_filt)
    ax4.set_title(f'Power Spectrum - Filtered Signal (Channel {ch.value})')
    ax4.set_xlabel('Frequency (Hz)')
    ax4.set_ylabel('Power/Frequency (dB/Hz)')
    ax4.grid(True)

    # Add vertical lines to show filter cutoff frequencies
    ax4.axvline(x=5, color='r', linestyle='--', label='Low cutoff (5 Hz)')
    ax4.axvline(x=500, color='r', linestyle='--', label='High cutoff (500 Hz)')
    ax4.legend()

    plt.tight_layout()
    plt.show()
    return (
        Pxx_filt,
        Pxx_orig,
        ax4,
        ax5,
        f_filt,
        f_orig,
        fig2,
        selected_channel_2,
    )


if __name__ == "__main__":
    app.run()
